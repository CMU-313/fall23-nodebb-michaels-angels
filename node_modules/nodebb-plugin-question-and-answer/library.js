'use strict';

const topics = require.main.require('./src/topics');//type: topics object
const posts = require.main.require('./src/posts'); //type: posts object
const categories = require.main.require('./src/categories'); //type: category object
const meta = require.main.require('./src/meta'); //type: meta object
const privileges = require.main.require('./src/privileges'); //type: privileges object
const rewards = require.main.require('./src/rewards'); //type: rewards object
const user = require.main.require('./src/user'); //type: user object
const helpers = require.main.require('./src/controllers/helpers'); //type: helpers object
const db = require.main.require('./src/database'); //type: database object
const plugins = require.main.require('./src/plugins');//type: plugins object
const SocketPlugins = require.main.require('./src/socket.io/plugins'); //type: socket.io element
const pagination = require.main.require('./src/pagination'); //type: pagination object
const social = require.main.require('./src/social'); //type: social object

const plugin = module.exports;

plugin.init = async function (params) {
	const { router } = params;
	const routeHelpers = require.main.require('./src/routes/helpers');

	routeHelpers.setupAdminPageRoute(router, '/admin/plugins/question-and-answer', renderAdmin);
	routeHelpers.setupPageRoute(router, '/unsolved', [], renderUnsolved);
	routeHelpers.setupPageRoute(router, '/solved', [], renderSolved);

	handleSocketIO();

	plugin._settings = await meta.settings.get('question-and-answer');
};

//returns: config object
plugin.appendConfig = async function (config) {
	config['question-and-answer'] = plugin._settings;
	return config;
};

//menu type: html object
//returns: void
plugin.addNavigation = async function (menu) {
	menu = menu.concat(
		[
			{
				route: '/unsolved',
				title: '[[qanda:menu.unsolved]]',
				iconClass: 'fa-question-circle',
				textClass: 'visible-xs-inline',
				text: '[[qanda:menu.unsolved]]',
			},
			{
				route: '/solved',
				title: '[[qanda:menu.solved]]',
				iconClass: 'fa-check-circle',
				textClass: 'visible-xs-inline',
				text: '[[qanda:menu.solved]]',
			},
		]
	);
	return menu;
};


//header type: acp header object
//returns: header object
plugin.addAdminNavigation = async function (header) {
	header.plugins.push({
		route: '/plugins/question-and-answer',
		icon: 'fa-question-circle',
		name: 'Q&A',
	});
	return header;
};



//hookData type: post object
//returns: post object
plugin.addAnswerDataToTopic = async function (hookData) {
	if (!parseInt(hookData.templateData.isQuestion, 10)) {
		return hookData;
	}

	hookData.templateData.icons.push(getIconMarkup(hookData.templateData.isSolved));
	return await addMetaData(hookData);
};


//hookData type: post object
//returns: post object
plugin.filterTopicGetPosts = async (hookData) => {
	const solvedPid = parseInt(hookData.topic.solvedPid, 10);
	if (!solvedPid) {
		return hookData;
	}
	const showBestAnswer = hookData.posts.length && hookData.posts[0].index === 0;
	if (!showBestAnswer) {
		hookData.posts.forEach((p) =>{
			if (p && p.pid === solvedPid) {
				p.allowDupe = true;
			}
		});
		return hookData;
	}

	//topicPosts type: post object array
	//answerIsNotFirstReply type: boolean
	//found type: post object
	const topicPosts = hookData.posts;
	const answerIsNotFirstReply = topicPosts.length > 1 && topicPosts[1].pid !== solvedPid;
	const found = topicPosts.find(p => p.pid === solvedPid);
	if (found && answerIsNotFirstReply) {
		const copy = { ...found };
		copy.allowDupe = true;
		copy.navigatorIgnore = true;
		copy.eventStart = 0;
		copy.eventEnd = 0
		topicPosts.splice(1, 0, copy);
	} else if (answerIsNotFirstReply) {
		const answers = await posts.getPostsByPids([solvedPid], hookData.uid);
		const [postsData, postSharing] = await Promise.all([
			topics.addPostData(answers, hookData.uid),
			social.getActivePostSharing(),
		]);
		let post = postsData[0];
		if (post) {
			const bestAnswerTopicData = { ...hookData.topic };
			bestAnswerTopicData.posts = postsData;
			bestAnswerTopicData.postSharing = postSharing;

			const topicPrivileges = await privileges.topics.get(hookData.topic.tid, hookData.uid);
			await topics.modifyPostsByPrivilege(bestAnswerTopicData, topicPrivileges);

			post = bestAnswerTopicData.posts[0];
			post.allowDupe = true;
			post.navigatorIgnore = true;
			const indices = await posts.getPostIndices([post], hookData.uid);
			post.index = indices[0];
			topicPosts.splice(1, 0, post);
		}
	}

	hookData.posts.forEach((post) => {
		if (post) {
			post.isAnswer = post.pid === solvedPid;
		}
	});

	return hookData;
};


//data type: post object array
//returns: post object array
async function addMetaData(data) {
	const { tid } = data.templateData;
	const { uid } = data.req;
	const pidsToFetch = [data.templateData.mainPid, await posts.getPidsFromSet(`tid:${tid}:posts:votes`, 0, 0, true)];
	let mainPost; let suggestedAnswer; let
		acceptedAnswer;

	if (data.templateData.solvedPid) {
		pidsToFetch.push(data.templateData.solvedPid);
	}

	const postsData = [mainPost, suggestedAnswer, acceptedAnswer] = await posts.getPostsByPids(pidsToFetch, uid);
	await topics.addPostData(postsData, uid);

	postsData.forEach((p) => {
		p.content = String(p.content || '')
			.replace(/\\/g, '\\\\')
			.replace(/\n/g, '\\n')
			.replace(/"/g, '\\"')
			.replace(/\t/g, '\\t');
	});

	data.templateData.mainPost = mainPost || {};
	data.templateData.acceptedAnswer = acceptedAnswer || {};
	if (suggestedAnswer && suggestedAnswer.pid !== data.templateData.mainPid) {
		data.templateData.suggestedAnswer = suggestedAnswer || {};
	}

	data.res.locals.postHeader = await data.req.app.renderAsync('partials/question-and-answer/topic-jsonld', data.templateData);
	return data;
}


//hookData type: topics object
//returns: topics object
plugin.getTopics = async function (hookData) {
	hookData.topics.forEach((topic) => {
		if (topic && parseInt(topic.isQuestion, 10)) {
			topic.icons.push(getIconMarkup(topic.isSolved));
		}
	});
	return hookData;
};

//isSolved type: boolean
//returns: html element
function getIconMarkup(isSolved) {
	if (parseInt(isSolved, 10)) {
		return '<span class="answered badge border text-success border-success"><i class="fa fa-check"></i><span> [[qanda:topic_solved]]</span></span>';
	}
	return '<span class="unanswered badge border text-warning border-warning"><i class="fa fa-question-circle"></i><span> [[qanda:topic_unsolved]]</span></span>';
}


//hookData type: topics object
//returns: topics object
plugin.filterPostGetPostSummaryByPids = async function (hookData) {
	const tids = hookData.posts.map(p => p && p.tid);
	const topicData = await topics.getTopicsFields(tids, ['isQuestion', 'isSolved']);
	hookData.posts.forEach((p, index) => {
		if (p && p.topic && topicData[index]) {
			p.topic.isQuestion = parseInt(topicData[index].isQuestion, 10);
			p.topic.isSolved = parseInt(topicData[index].isSolved, 10);
		}
	});
	return hookData;
};


//hookData type: posts object
//returns: posts object
plugin.addThreadTool = async function (hookData) {
	const isSolved = parseInt(hookData.topic.isSolved, 10);

	if (parseInt(hookData.topic.isQuestion, 10)) {
		hookData.tools = hookData.tools.concat([
			{
				class: `toggleSolved ${isSolved ? 'topic-solved' : 'topic-unsolved'}`,
				title: isSolved ? '[[qanda:thread.tool.mark_unsolved]]' : '[[qanda:thread.tool.mark_solved]]',
				icon: isSolved ? 'fa-question-circle' : 'fa-check-circle',
			},
			{
				class: 'toggleQuestionStatus',
				title: '[[qanda:thread.tool.make_normal]]',
				icon: 'fa-comments',
			},
		]);
	} else {
		hookData.tools.push({
			class: 'toggleQuestionStatus',
			title: '[[qanda:thread.tool.as_question]]',
			icon: 'fa-question-circle',
		});
	}
	return hookData;
};


//hookData type: topics object
//returns: topics object
plugin.addPostTool = async function (hookData) {
	const data = await topics.getTopicDataByPid(hookData.pid);
	if (!data) {
		return hookData;
	}

	data.isSolved = parseInt(data.isSolved, 10) === 1;
	data.isQuestion = parseInt(data.isQuestion, 10) === 1;
	const canSolve = await canSetAsSolved(data.tid, hookData.uid);
	if (canSolve && data.isQuestion &&
		parseInt(hookData.pid, 10) !== parseInt(data.solvedPid, 10) &&
		parseInt(hookData.pid, 10) !== parseInt(data.mainPid, 10)) {
		hookData.tools.push({
			action: 'qanda/post-solved',
			html: '[[qanda:post.tool.mark_correct]]',
			icon: 'fa-check-circle',
		});
	}
	return hookData;
};

//condition type: string arr
plugin.getConditions = async function (conditions) {
	conditions.push({
		name: 'Times questions accepted',
		condition: 'qanda/question.accepted',
	});
	return conditions;
};

//payload type: topics object 
//returns: payload object
plugin.onTopicCreate = async function (payload) {
	let isQuestion;
	if (payload.data.hasOwnProperty('isQuestion')) {
		isQuestion = true;
	}

	// Overrides from ACP config
	if (plugin._settings.forceQuestions === 'on' || plugin._settings[`defaultCid_${payload.topic.cid}`] === 'on') {
		isQuestion = true;
	}

	if (!isQuestion) {
		return payload;
	}

	await topics.setTopicFields(payload.topic.tid, { isQuestion: 1, isSolved: 0 });
	await db.sortedSetAdd('topics:unsolved', Date.now(), payload.topic.tid);
	return payload;
};

